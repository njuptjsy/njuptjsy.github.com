
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>More Than Words</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Siyu Jin">
    

    
    <meta name="description" content="学习总结 思考感悟 知识管理">
<meta property="og:type" content="website">
<meta property="og:title" content="More Than Words">
<meta property="og:url" content="http://njuptjsy.github.io/index.html">
<meta property="og:site_name" content="More Than Words">
<meta property="og:description" content="学习总结 思考感悟 知识管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="More Than Words">
<meta name="twitter:description" content="学习总结 思考感悟 知识管理">

    
    <link rel="alternative" href="/atom.xml" title="More Than Words" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="More Than Words" title="More Than Words"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="More Than Words">More Than Words</a></h1>
				<h2 class="blog-motto">Perfection is not attainable, but if we chase it we can catch excellence.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:njuptjsy.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand new" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/08/根据byte[]生成String和getByte遇到的问题-开发笔记/" title="阿里云实现listBucket--开发笔记" itemprop="url">阿里云实现listBucket--开发笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Siyu Jin" target="_blank" itemprop="author">Siyu Jin</a>
		
  <p class="article-time">
    <time datetime="2015-06-08T07:14:27.000Z" itemprop="datePublished"> 发表于 2015-06-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="背景">背景</h1><p>开发CloudClient的阿里云上传下载模块，本来以为可以愉快的使用阿里云的各种封装好的API,没想到刚刚开始开发下载文件就遇到了问题。阿里云并没有提供具体的根据用户名密码列举该用户名下所有Bucket的方法。</p>
<p>通过阅读其官网描述的API,发现可以基于RESTful的架构自己向阿里云服务器发送请求，从响应消息中解析所需要的信息。列举所以用户名下所有Bucket的方式是进行<a href="http://docs.aliyun.com/?spm=5176.383663.9.2.52hqzx#/pub/oss/api-reference/service&amp;GetService" target="_blank" rel="external">GetService操作</a>需要构造一个格式如下的Http请求报文<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">GET <span class="string">/</span> HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span>: <span class="string">oss.aliyuncs.com</span></span><br><span class="line"><span class="attribute">Date</span>: <span class="string">GMT Date</span></span><br><span class="line"><span class="attribute">Authorization</span>: <span class="string">SignatureValue</span></span><br></pre></td></tr></table></figure></p>
<p>其他的都不难理解，就唯独其中的签名Authorization: SignatureValue的生成让人费解，光是看阿里云提供的<a href="http://docs.aliyun.com/?spm=5176.383663.9.2.52hqzx#/pub/oss/api-reference/access-control&amp;signature-header" target="_blank" rel="external">签名生成方法</a>就花了很大精力。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Authorization: OSS "</span> + Access Key Id + <span class="string">":"</span> + Signature</span><br><span class="line"></span><br><span class="line">Signature = base64<span class="list">(<span class="keyword">hmac-sha1</span><span class="list">(<span class="keyword">AccessKeySecret</span>,</span><br><span class="line">            VERB + <span class="string">"\n"</span> </span><br><span class="line">            + CONTENT-MD5 + <span class="string">"\n"</span> </span><br><span class="line">            + CONTENT-TYPE + <span class="string">"\n"</span> </span><br><span class="line">            + DATE + <span class="string">"\n"</span> </span><br><span class="line">            + CanonicalizedOSSHeaders</span><br><span class="line">            + CanonicalizedResource)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>花了很长时间研究CONTENT-MD5、CONTENT-TYPE到底是什么，还有给出的例子中明明是先用RFC 2104中定义的HMAC-SHA1方法以Access Key Secret为密钥加密然后再BASE64编码成字符串就可以了，但在下面的Python实现中还用到digest方法计算加密后数据的MD5，到底那个是正确的让人很迷惑。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> sha</span><br><span class="line">h = hmac.new(<span class="string">"OtxrzxIsfpFjA7SwPzILwy8Bw21TLhquhboDYROV"</span>,</span><br><span class="line">             <span class="string">"PUT\nODBGOERFMDMzQTczRUY3NUE3NzA5QzdFNUYzMDQxNEM=\ntext/html\nThu, 17 Nov 2005 18:49:58 GMT\nx-oss-magic:abracadabra\nx-oss-meta-author:foo@bar.com\n/oss-example/nelson"</span>, sha)</span><br><span class="line">base64.encodestring(h.digest()).strip()</span><br></pre></td></tr></table></figure></p>
<h1 id="问题描述">问题描述</h1><p>综上所述，在花了很长时间理解阿里云的文档之后，开始实现getService服务。第一步,需要通过HttpClient构建一个HttpGet消息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = <span class="keyword">new</span> DefaultHttpClient();</span><br><span class="line">String host = <span class="string">"oss.aliyuncs.com"</span>;</span><br><span class="line"></span><br><span class="line">URI url = URIUtils.createURI(<span class="string">"http"</span>, host, -<span class="number">1</span>, <span class="string">"/"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//ublic static URI createURI(String scheme,String host,int port,String path,String query,String fragment)</span></span><br><span class="line">LogUtil.i(<span class="string">"QueryAliyun:sendHttpGet"</span>, url+<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">HttpGet httpGet = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line">httpGet.addHeader(<span class="string">"Date"</span>, getSystemTime());</span><br><span class="line">httpGet.addHeader(<span class="string">"Host"</span>,<span class="string">"oss.aliyuncs.com"</span>);</span><br><span class="line">httpGet.addHeader(<span class="string">"Authorization"</span>, getSignature());</span><br></pre></td></tr></table></figure></p>
<p>第二步，需要按照文档中描述的方式对本次请求进行加密。问题就出现在这一步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getSignature</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String encryptText = <span class="string">"GET"</span> + <span class="string">"\n"</span> </span><br><span class="line">	            + <span class="string">""</span> + <span class="string">"\n"</span> </span><br><span class="line">	            + <span class="string">""</span> + <span class="string">"\n"</span> </span><br><span class="line">	            + getSystemTime() + <span class="string">"\n"</span> </span><br><span class="line">	            + <span class="string">""</span></span><br><span class="line">	            + <span class="string">"/"</span>;</span><br><span class="line">		</span><br><span class="line">		String signature = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String signatureTemp = ClientUtils.HmacSHA1Encrypt(InfoContainer.ALIYUN_SCRECT_ID, encryptText);</span><br><span class="line">       </span><br><span class="line">			signature = Base64.encodeToString(signatureTemp.getByte(), Base64.DEFAULT).trim();</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			LogUtil.e(<span class="string">"QueryAliyun:getSignature"</span>, <span class="string">" catch exception in HmacSHA1Encrypt"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		String authorization = <span class="string">"OSS "</span> + InfoContainer.ALIYUN_ACCESS_ID + <span class="string">":"</span> + signature;</span><br><span class="line">		<span class="keyword">return</span> authorization;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>我将要加密的文本按照指定的算法进行加密，返回加密结果字符串，再使用BASE64方式编码，与服务器通信后始终是403错误。研究了很久，发现使用阿里云提供的方法对同样的内容进行签名操作就可以通信，于是我将该方法的结果进行BASE64解码，发现解码的结果和使用ClientUtils.HmacSHA1Encrypt方法放回的字符串一样。根据这个结论进一步研究猜测问题出现在signatureTemp.getByte()这个方法上，我将加密的结果作为byte[]返回，而不是先转换成字符串在装换成byte数组，再进行BASE64编码就可以正常通信了。</p>
<p>这让我怀疑通过new String()得到的字符串，再进行getByte[]操作无法得到原有的byte数组。因为new String和getByte方法在不指定编码方式的情况下都是使用当前环境的编码方式，这里是UTF-8，于是我使用了下面的方法进行测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testGetbyte</span><span class="params">(<span class="keyword">byte</span>[] signatureTemp)</span> </span>&#123;</span><br><span class="line">		String testString;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			testString = <span class="keyword">new</span> String(signatureTemp,<span class="string">"UTF-8"</span>);</span><br><span class="line">			<span class="keyword">byte</span>[] testBytes = testString.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">			LogUtil.i(<span class="string">"QueryAliyun:testGetbyte"</span>, signatureTemp + <span class="string">" and "</span> + testBytes);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现在utf-8的编码规则下，将byte数组装换成字符串在将字符串转换成byte数组，源数组不等于操作过后的数组。进一步研究，发现原因是因为UTF-8编码方式并不是采用单字节的编码方式进行转换，如果将这里的编码方式改成ISO-8859-1，源数组就和操作后的得到的数组一致了。这个坑也是导致我在这个地方花费了很长时间。</p>
<p>第三步，解析返回的数据</p>
<h1 id="总结下">总结下</h1><p>这里虽然ISO-8859-1来编码可以解码出原来的byte数组，但是使用不管什么内容，都用new String(…,”ISO-8859-1”)来建立字符串，然后使用的时候按默认的编码格式（通常在服务器上都是英文系统）输出字符串。这样其实你使用的String并不是按UNICODE来代表真正的字符，而是强行把BYTE数组复制到String的char[]里，一旦你的运行环境改变，你就被迫要修改一大堆的代码。而且也无法在同一个字符串里处理几种不同编码的文字。<br>另一个是把一种编码格式的字符串，比如是GB2312，转换成另一种格式的字符串，比如UTF-8，然后不指明是UTF-8编码，而直接用new String(…)来建立String，这样放在String里面的字符也是无法确定的，它在不同的系统上代表不同的字符。如果要求别人用“UTF-8格式”的String来交换信息的时候，其实已经破坏了JAVA为了兼容各种语言所做的规定。这种错误的本质思想是还按写C语言的方式，把字符串纯粹当作可以自己自由编码的存储器使用，而忽略了JAVA字符串只有一种编码格式。如果真的想自由编码，用byte[]或者char[]就完全了解决问题的了。 </p>
<p>这里不得不吐槽下阿里云的Android API,对各项操作的封装不全也就算了，文档中几乎没有说明性的描述，绝大部分函数都没有任何的说明的文字，传入的形参和返回值也只告诉你类型，使用基本靠猜。即使对自己的命名再有信心，几句说明还是应该有的，具体可以看看AWS的API。<br><img src="https://raw.githubusercontent.com/njuptjsy/mobliecloudapp/master/CloudClient/uml/%E9%98%BF%E9%87%8C%E4%BA%91androidAPI%E6%88%AA%E5%9B%BE.png" alt="image"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Work/">Work</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android-Code/">Android Code</a><a href="/tags/CloudClient/">CloudClient</a><a href="/tags/Debug/">Debug</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/08/根据byte[]生成String和getByte遇到的问题-开发笔记/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand new" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/08/阿里云实现listBucket-开发笔记/" title="阿里云实现listBucket--开发笔记" itemprop="url">阿里云实现listBucket--开发笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Siyu Jin" target="_blank" itemprop="author">Siyu Jin</a>
		
  <p class="article-time">
    <time datetime="2015-06-08T07:14:27.000Z" itemprop="datePublished"> 发表于 2015-06-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="阿里云文档">阿里云文档</h1><p>开发CloudClient的阿里云上传下载模块，本来以为像listBucket可以愉快的使用阿里云的各种封装好的API,没想到刚刚开始开发下载文件就遇到了问题。阿里云并没有提供具体的根据用户名密码列举该用户名下所有Bucket的方法。</p>
<p>通过阅读其官网描述的API,发现可以基于RESTful的架构自己向阿里云服务器发送请求，从响应消息中解析所需要的信息。列举所以用户名下所有Bucket的方式是进行<a href="http://docs.aliyun.com/?spm=5176.383663.9.2.52hqzx#/pub/oss/api-reference/service&amp;GetService" target="_blank" rel="external">GetService操作</a>需要构造一个格式如下的Http请求报文<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">GET <span class="string">/</span> HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span>: <span class="string">oss.aliyuncs.com</span></span><br><span class="line"><span class="attribute">Date</span>: <span class="string">GMT Date</span></span><br><span class="line"><span class="attribute">Authorization</span>: <span class="string">SignatureValue</span></span><br></pre></td></tr></table></figure></p>
<p>其他的都不难理解，就唯独其中的签名Authorization: SignatureValue的生成让人费解，光是看阿里云提供的<a href="http://docs.aliyun.com/?spm=5176.383663.9.2.52hqzx#/pub/oss/api-reference/access-control&amp;signature-header" target="_blank" rel="external">签名生成方法</a>就花了很大精力。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Authorization: OSS "</span> + Access Key Id + <span class="string">":"</span> + Signature</span><br><span class="line"></span><br><span class="line">Signature = base64<span class="list">(<span class="keyword">hmac-sha1</span><span class="list">(<span class="keyword">AccessKeySecret</span>,</span><br><span class="line">            VERB + <span class="string">"\n"</span> </span><br><span class="line">            + CONTENT-MD5 + <span class="string">"\n"</span> </span><br><span class="line">            + CONTENT-TYPE + <span class="string">"\n"</span> </span><br><span class="line">            + DATE + <span class="string">"\n"</span> </span><br><span class="line">            + CanonicalizedOSSHeaders</span><br><span class="line">            + CanonicalizedResource)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>花了很长时间研究CONTENT-MD5、CONTENT-TYPE到底是什么，还有给出的例子中明明是先用RFC 2104中定义的HMAC-SHA1方法以Access Key Secret为密钥加密然后再BASE64编码成字符串就可以了，但在下面的Python实现中还用到digest方法计算加密后数据的MD5，到底那个是正确的让人很迷惑。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> sha</span><br><span class="line">h = hmac.new(<span class="string">"OtxrzxIsfpFjA7SwPzILwy8Bw21TLhquhboDYROV"</span>,</span><br><span class="line">             <span class="string">"PUT\nODBGOERFMDMzQTczRUY3NUE3NzA5QzdFNUYzMDQxNEM=\ntext/html\nThu, 17 Nov 2005 18:49:58 GMT\nx-oss-magic:abracadabra\nx-oss-meta-author:foo@bar.com\n/oss-example/nelson"</span>, sha)</span><br><span class="line">base64.encodestring(h.digest()).strip()</span><br></pre></td></tr></table></figure></p>
<h1 id="开发步骤">开发步骤</h1><p>综上所述，在花了很长时间理解阿里云的文档之后，开始实现getService服务。第一步,需要通过HttpClient构建一个HttpGet消息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = <span class="keyword">new</span> DefaultHttpClient();</span><br><span class="line">String host = <span class="string">"oss.aliyuncs.com"</span>;</span><br><span class="line"></span><br><span class="line">URI url = URIUtils.createURI(<span class="string">"http"</span>, host, -<span class="number">1</span>, <span class="string">"/"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//ublic static URI createURI(String scheme,String host,int port,String path,String query,String fragment)</span></span><br><span class="line">LogUtil.i(<span class="string">"QueryAliyun:sendHttpGet"</span>, url+<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">HttpGet httpGet = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line">httpGet.addHeader(<span class="string">"Date"</span>, getSystemTime());</span><br><span class="line">httpGet.addHeader(<span class="string">"Host"</span>,<span class="string">"oss.aliyuncs.com"</span>);</span><br><span class="line">httpGet.addHeader(<span class="string">"Authorization"</span>, getSignature());</span><br></pre></td></tr></table></figure></p>
<h2 id="问题描述">问题描述</h2><p>第二步，需要按照文档中描述的方式对本次请求进行加密。问题就出现在这一步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getSignature</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String encryptText = <span class="string">"GET"</span> + <span class="string">"\n"</span> </span><br><span class="line">	            + <span class="string">""</span> + <span class="string">"\n"</span> </span><br><span class="line">	            + <span class="string">""</span> + <span class="string">"\n"</span> </span><br><span class="line">	            + getSystemTime() + <span class="string">"\n"</span> </span><br><span class="line">	            + <span class="string">""</span></span><br><span class="line">	            + <span class="string">"/"</span>;</span><br><span class="line">		</span><br><span class="line">		String signature = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String signatureTemp = ClientUtils.HmacSHA1Encrypt(InfoContainer.ALIYUN_SCRECT_ID, encryptText);</span><br><span class="line">       </span><br><span class="line">			signature = Base64.encodeToString(signatureTemp.getByte(), Base64.DEFAULT).trim();</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			LogUtil.e(<span class="string">"QueryAliyun:getSignature"</span>, <span class="string">" catch exception in HmacSHA1Encrypt"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		String authorization = <span class="string">"OSS "</span> + InfoContainer.ALIYUN_ACCESS_ID + <span class="string">":"</span> + signature;</span><br><span class="line">		<span class="keyword">return</span> authorization;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="javadoc">/**  </span><br><span class="line">     * 使用 HMAC-SHA1 签名方法对对encryptText进行签名  </span><br><span class="line">     *<span class="javadoctag"> @param</span> encryptText 被签名的字符串  </span><br><span class="line">     *<span class="javadoctag"> @param</span> encryptKey  密钥  </span><br><span class="line">     *<span class="javadoctag"> @return</span> 前面后的byte数组</span><br><span class="line">     *<span class="javadoctag"> @throws</span> Exception  </span><br><span class="line">     */</span>   </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">HmacSHA1Encrypt</span><span class="params">(String encryptKey,String encryptText)</span> <span class="keyword">throws</span> Exception     </span><br><span class="line">    </span>&#123;   </span><br><span class="line">		String macMethod = <span class="string">"HmacSHA1"</span>;</span><br><span class="line">		String encoding = <span class="string">"UTF-8"</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] keyBytes=encryptKey.getBytes(encoding);  </span><br><span class="line">        SecretKey secretKey = <span class="keyword">new</span> SecretKeySpec(keyBytes, macMethod);<span class="comment">//根据给定的字节数组构造一个密钥,第二参数指定一个密钥算法的名称     </span></span><br><span class="line">        Mac mac = Mac.getInstance(macMethod);<span class="comment">//生成一个指定 Mac算法 的 Mac对象     </span></span><br><span class="line">        mac.init(secretKey);<span class="comment">//用给定密钥初始化 Mac 对象      </span></span><br><span class="line">        <span class="keyword">byte</span>[] text = encryptText.getBytes(encoding);    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(mac.doFinal(text));    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我将要加密的文本按照指定的算法进行加密，返回加密结果字符串，再使用BASE64方式编码，与服务器通信后始终是403错误。研究了很久，发现使用阿里云提供的方法对同样的内容进行签名操作就可以通信，于是我将该方法的结果进行BASE64解码，发现解码的结果和使用ClientUtils.HmacSHA1Encrypt方法放回的字符串一样。根据这个结论进一步研究猜测问题出现在signatureTemp.getByte()这个方法上，我将加密的结果作为byte[]返回，而不是先转换成字符串在装换成byte数组，再进行BASE64编码就可以正常通信了。</p>
<p>这让我怀疑通过new String()得到的字符串，再进行getByte[]操作无法得到原有的byte数组。因为new String和getByte方法在不指定编码方式的情况下都是使用当前环境的编码方式，这里是UTF-8，于是我使用了下面的方法进行测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">testGetbyte</span><span class="params">(<span class="keyword">byte</span>[] signatureTemp)</span> </span>&#123;</span><br><span class="line">		String testString;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			testString = <span class="keyword">new</span> String(signatureTemp,<span class="string">"UTF-8"</span>);</span><br><span class="line">			<span class="keyword">byte</span>[] testBytes = testString.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">			LogUtil.i(<span class="string">"QueryAliyun:testGetbyte"</span>, signatureTemp + <span class="string">" and "</span> + testBytes);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现在utf-8的编码规则下，将byte数组装换成字符串在将字符串转换成byte数组，源数组不等于操作过后的数组。进一步研究，发现原因是因为UTF-8编码方式并不是采用单字节的编码方式进行转换，如果将这里的编码方式改成ISO-8859-1，源数组就和操作后的得到的数组一致了。这个坑也是导致我在这个地方花费了很长时间。</p>
<p>第三步，解析返回的数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">			HttpResponse httpResponse = httpClient.execute(httpGet);</span><br><span class="line">			<span class="keyword">if</span> (httpResponse.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line"></span><br><span class="line">				HttpEntity entity = httpResponse.getEntity();</span><br><span class="line">				String result = EntityUtils.toString(entity,<span class="string">"UTF-8"</span>);</span><br><span class="line">				LogUtil.i(<span class="string">"alyunQuery:sendHttpGet"</span>, result);</span><br><span class="line">				parseXMLWithPull(result);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				LogUtil.e(<span class="string">"alyunQuery:sendHttpGet"</span>, <span class="string">"response wrong stauts code:"</span>+ httpResponse.getStatusLine().getStatusCode());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，校验状态码是否正常为200，接着取出相应消息中的响应体，这里的相应体内容如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">ListAllMyBucketsResult</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">Owner</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ID</span>&gt;</span>1173032044021568<span class="tag">&lt;/<span class="title">ID</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">DisplayName</span>&gt;</span>1173032044021568<span class="tag">&lt;/<span class="title">DisplayName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">Owner</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">Buckets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">Bucket</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">Location</span>&gt;</span>oss-cn-beijing<span class="tag">&lt;/<span class="title">Location</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">Name</span>&gt;</span>njuptjsy<span class="tag">&lt;/<span class="title">Name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">CreationDate</span>&gt;</span>2015-05-23T04:06:57.000Z<span class="tag">&lt;/<span class="title">CreationDate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">Bucket</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">Buckets</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ListAllMyBucketsResult</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到服务器发回的消息中包含在Buckets标签，其中用每个子标签bucket包含了相应的bucket的位置、名称、和创建时间信息。下面只需要将开放需要的名称信息提取出来保存在列表中即可。Android对xml的解析在Android中一共有三种方法：<br>1.SAX解析XML文件采用的是事件驱动，也就是说，他读取每个标签并不需要解析完整个文档，在按内容顺序解析文档的过程中，SAX会判断当前读取到的字符是否符合XML语法中的某部分，如果符合就会触发事件，其实就是一些回调方法，然后进行判断处理。其优点是解析速度快，占用内存少，适用于Android等移动设备，缺点是对于嵌套多个分支的XML文件来说处理不是很方便。</p>
<p>2.DOM解析XML文件时，会将XML文件的所有内容以文档树方式存放在内存中，然后使用DOM API遍历XML树，检索所需的数据，主要用于PC机。其优点是使用DOM解析XML的代码比较直观，相比于基于SAX的实现更加简单，缺点是须将XML文件所有内容存放在内存中，所以消耗内存大，不适用Android等移动设备。</p>
<p>3.Pull解析器是Android内置解析XML文件的解析器，运行方式类似于SAX解析，只是产生的事件是一个数字，而非方法，因此可以使用一个switch对感兴趣的事件进行处理。Pull解析器对节点处理比较好，同样也很省内存，官方推挤使用Pull解析器解析XML文件，而且Android系统本身用到的XML文件内部也是使用Pull解析器进行解析的。这里选用的Pull方法进行解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseXMLWithPull</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			XmlPullParserFactory factory = XmlPullParserFactory.newInstance();</span><br><span class="line">			XmlPullParser xmlPullParser = factory.newPullParser();</span><br><span class="line">			xmlPullParser.setInput(<span class="keyword">new</span> StringReader(result));</span><br><span class="line">			<span class="keyword">int</span> eventType = xmlPullParser.getEventType();</span><br><span class="line">			</span><br><span class="line">			String name = <span class="string">""</span>;</span><br><span class="line">			String location = <span class="string">""</span>;</span><br><span class="line">			bucketNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">			<span class="keyword">while</span> (eventType != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">				String nodeName = xmlPullParser.getName();</span><br><span class="line">				<span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">				<span class="keyword">case</span> XmlPullParser.START_TAG:</span><br><span class="line">					<span class="keyword">if</span> (<span class="string">"Location"</span>.equals(nodeName)) &#123;</span><br><span class="line">						location = xmlPullParser.nextText();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(<span class="string">"Name"</span>.equals(nodeName)</span>)</span>&#123;</span><br><span class="line">						name = xmlPullParser.nextText();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> XmlPullParser.END_TAG:</span><br><span class="line">					<span class="keyword">if</span> (<span class="string">"Bucket"</span>.equals(nodeName)) &#123;</span><br><span class="line">						bucketNames.add(name);</span><br><span class="line">						LogUtil.i(<span class="string">"alyunQuery:parseXMLWithPull"</span>, <span class="string">"get name :"</span> + name);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				eventType = xmlPullParser.next();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			LogUtil.e(<span class="string">"alyunQuery:parseXMLWithPull"</span>, <span class="string">"parse XML error"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>在parseXMLWithPull函数中，通过工程方法生成xmlPullParser对象对传入的带解析的流进行解析。pull解析在遇到不同的XML标签时会触发不同的事件，如这里用到的遇到标签的起始事件XmlPullParser.START_TAG、遇到标签的结束事件XmlPullParser.END_TAG和遇到XML文件结束标签事件XmlPullParser.END_DOCUMENT。</p>
<h1 id="总结下">总结下</h1><p>这里虽然ISO-8859-1来编码可以解码出原来的byte数组，但是使用不管什么内容，都用new String(…,”ISO-8859-1”)来建立字符串，然后使用的时候按默认的编码格式（通常在服务器上都是英文系统）输出字符串。这样其实你使用的String并不是按UNICODE来代表真正的字符，而是强行把BYTE数组复制到String的char[]里，一旦你的运行环境改变，你就被迫要修改一大堆的代码。而且也无法在同一个字符串里处理几种不同编码的文字。<br>另一个是把一种编码格式的字符串，比如是GB2312，转换成另一种格式的字符串，比如UTF-8，然后不指明是UTF-8编码，而直接用new String(…)来建立String，这样放在String里面的字符也是无法确定的，它在不同的系统上代表不同的字符。如果要求别人用“UTF-8格式”的String来交换信息的时候，其实已经破坏了JAVA为了兼容各种语言所做的规定。这种错误的本质思想是还按写C语言的方式，把字符串纯粹当作可以自己自由编码的存储器使用，而忽略了JAVA字符串只有一种编码格式。如果真的想自由编码，用byte[]或者char[]就完全了解决问题的了。 </p>
<p>这里不得不吐槽下阿里云的Android API,对各项操作的封装不全也就算了，文档中几乎没有说明性的描述，绝大部分函数都没有任何的说明的文字，传入的形参和返回值也只告诉你类型，使用基本靠猜。即使对自己的命名再有信心，几句说明还是应该有的，具体可以看看AWS的API。<br><img src="https://raw.githubusercontent.com/njuptjsy/mobliecloudapp/master/CloudClient/uml/%E9%98%BF%E9%87%8C%E4%BA%91androidAPI%E6%88%AA%E5%9B%BE.png" alt="image"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Work/">Work</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android-Code/">Android Code</a><a href="/tags/CloudClient/">CloudClient</a><a href="/tags/Debug/">Debug</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/08/阿里云实现listBucket-开发笔记/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand new" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/08/MVC模式/" title="MVC模式" itemprop="url">MVC模式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Siyu Jin" target="_blank" itemprop="author">Siyu Jin</a>
		
  <p class="article-time">
    <time datetime="2015-06-08T07:14:27.000Z" itemprop="datePublished"> 发表于 2015-06-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="基本概念">基本概念</h1><p>MVC的主要作用是将应用程序的数据和界面分离，其中M表示Model代表模型，V表示view代表界面，C表示控制器控制M和V之间的联系。Android SDK也采用MVC。<br>当View数据变化时，其通知Controller，由Controller操作Model进行相应的数据操作。将数据和视图分离之后跟换视图和模型是可以不影响对方，更利于程序维护。Android中典型的例子就是各种列表组件作为View（ListView、GridView、Spinner等），各种适配器作为Controller（BaseAdapter、SimpleAdapter、ArrayAdapter、SimpleCousorAdaptr和CousorAdaptr），对于的Model有数组和Cursor等。当Model变化时，调用notifyDataSetChanged方法通知C，C通过getView重新绘制组件内容。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android-Code/">Android Code</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/08/MVC模式/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand new" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/08/Android系统架构/" title="Android系统架构" itemprop="url">Android系统架构</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Siyu Jin" target="_blank" itemprop="author">Siyu Jin</a>
		
  <p class="article-time">
    <time datetime="2015-06-08T07:14:27.000Z" itemprop="datePublished"> 发表于 2015-06-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><img src="https://raw.githubusercontent.com/njuptjsy/mobliecloudapp/master/CloudClient/uml/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.jpg" alt="image"><br>如图所示主要分4层<br>1.运行在Dalvik虚拟机（基于寄存器的java虚拟机，运行速度更快）上的系统应用。</p>
<p>2.应用框架层（framework）：包括客户端和服务端<br>其中，服务端主要组件有：<br>WmS(管理Window大小调节叠放层次、隐藏或显示)<br>AmS（管理Activity并负责与应用程序主进程ActivityThread进行通信）<br>WmS.KeyQ（读取用户的操作，存放在消息队列QueueEvent中）<br>InputDispatchThread（取出QueueEvent中的消息，分发给应用）<br>客户端组件有：<br>ActivityThread：主线程UI线程，一个应用一个，入口是static main<br>Activity：应用运行的最小单元，一个应用多个<br>Window：提供通用窗口操作API<br>PhoneWindow：继承window类，对FrameLayout进行包装并提供操作API<br>PhoneWindow.DecorVeiw:对普通FrameLayout进行修饰相应特定按键消息<br>ViewRoot：继承Handler，接收WmS的通知<br>ViewRoot.V:继承Binder，向WmS提供IPC接口<br>WindowManage：客户端和WmS之间的代理</p>
<p>3.系统运行库：NDK使用C\C++编写主要是.so文件。主要包括C标准库、OpenGL ES、SQLit、Webkit和Dalvik虚拟机等。</p>
<p>4.linux内核层，包括驱动、内存管理、进程管理、网络协议栈等。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android-Code/">Android Code</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/08/Android系统架构/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/26/Android开发技巧-碎片/" title="Android开发技巧--碎片" itemprop="url">Android开发技巧--碎片</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Siyu Jin" target="_blank" itemprop="author">Siyu Jin</a>
		
  <p class="article-time">
    <time datetime="2015-05-26T05:15:00.000Z" itemprop="datePublished"> 发表于 2015-05-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="概念总结">概念总结</h1><p>为了应付Android设备各种尺寸的屏幕，为这些设备提供一个统一的解决方案，Android推出了Fragment组件。一种可以嵌入活动当中的UI片段。Android提供了位于两个不同包下的Fragment对象，android.app.Fragment支持Android4.0以上的版本，另一个包主要是兼容低版本的Android系统。</p>
<h2 id="简单实现">简单实现</h2><p>要实现对Fragment的使用，首要需要和普通的UI布局一样声明该Fragment对应的布局，接着新建一个类继承自android.app.Fragment的自定义类，复写其中的onCreateView方法在其中通过LayoutInflater将刚才定义的left_fragment动态的加载进来。下面是一个小例子：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">	<span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">	<span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">	<span class="attribute">android:background</span>=<span class="value">"#00ff00"</span></span><br><span class="line">	<span class="attribute">android:orientation</span>=<span class="value">"vertical"</span> &gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">		<span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">		<span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">		<span class="attribute">android:layout_gravity</span>=<span class="value">"center_horizontal"</span></span><br><span class="line">		<span class="attribute">android:textSize</span>=<span class="value">"20sp"</span></span><br><span class="line">		<span class="attribute">android:text</span>=<span class="value">"This is right fragment"</span></span><br><span class="line">	/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>继承Fragment并复写其中onCreateView()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		View view = inflater.inflate(R.layout.left_fragment, container, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">return</span> view;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在布局文件中，可以通过了fragment标签添加碎片，其中通过android:name来制定相应的属性来显式指明要添加的碎片类名<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">fragment</span></span><br><span class="line">	<span class="attribute">android:id</span>=<span class="value">"@+id/left_fragment"</span></span><br><span class="line">	<span class="attribute">android:name</span>=<span class="value">"com.example.fragmenttest.LeftFragment"</span></span><br><span class="line">	<span class="attribute">android:layout_width</span>=<span class="value">"0dp"</span></span><br><span class="line">	<span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">	<span class="attribute">android:layout_weight</span>=<span class="value">"1"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="动态的添加碎片">动态的添加碎片</h2><p>和上面的例子，首先需要声明碎片的布局文件，定义继承了Fragment的类并复写其中的onCreateView方法，在其中加载刚刚声明的布局文件。到这边都和全面一样，下面是在代码中实现动态添加碎片（碎片类名为AnotherRightFragment）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AnotherRightFragment fragment = <span class="keyword">new</span> AnotherRightFragment();</span><br><span class="line">FragmentManager fragmentManager = getFragmentManager();</span><br><span class="line">FragmentTransaction transaction = fragmentManager.beginTransaction();</span><br><span class="line">transaction.replace(R.id.right_layout, fragment);</span><br><span class="line">transaction.commit();</span><br></pre></td></tr></table></figure></p>
<p>可以将上面的步骤总结如下：<br>1.新建一个待添加的碎片实例<br>2.在活动类中使用getFragmentManager()方法获取fragmentManager对象实例<br>3.利用fragmentManager对象实例调用beginTransaction方法开启一个事务，传入要替换的组件id和待添加的碎片实例，进行替换操作<br>4.提交事务</p>
<h2 id="碎片中的返回栈">碎片中的返回栈</h2><p>为了像Activity一样利用backstack实现放回键退回到上一个界面，FragmentTransaction 中提供了一个addToBackStack()方法，可以用于将一个事务添加到返回栈中，只需要在transaction.replace方法后加入，transaction.addToBackStack(null);将这个事务加入到返回栈即可。其中传入的参数用于描述返回栈的名字。</p>
<h2 id="碎片通信">碎片通信</h2><p>在活动实现与碎片通信是通过FragmentManager的findFragmentById方法，从布局文件相应的组件中获取的碎片类对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RightFragment rightFragment = (RightFragment) getFragmentManager().findFragmentById(R.id.right_fragment);</span><br></pre></td></tr></table></figure></p>
<p>在碎片中实现与活动通信使用getActivity方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainActivity activity = (MainActivity) getActivity();</span><br></pre></td></tr></table></figure></p>
<p>碎片之间的通信也是通过活动组件，首先在一个活动组件中活动与其相关的活动类，接着利用这个活动去获得另一个碎片即可。</p>
<h2 id="碎片生命周期">碎片生命周期</h2><p>首先onAttach()方法（当碎片和活动建立关联的时候调用）、onCreateView()方法（为碎片创建视图（加载布局）时调用）和onActivityCreated()方法（确保与碎片相关联的活动一定已经创建完毕的时候调用），回调完毕时碎片是可见的，他所相关的活动和其本身正处于运行状态。<br>碎片进入暂停状态是随着活动进如暂停转态，碎片也会进入暂停状态。<br>碎片进入停止状态的情况有，当活动进入停止状态时、调用了FragmentTransaction的remove和replace方法将碎片移除且在调用的addToBackStack方法。<br>碎片进入销毁状态的情况有，活动被销毁，调用了FragmentTransaction的remove和replace方法将碎片移除但没有在调用的addToBackStack方法，进入本状态依次回调onDestroyView()方法(当与碎片关联的视图被移除的时候调用）onDetach()方法（当碎片和活动解除关联的时候调用）。<br>将碎片的生命周期和活动一起考虑，各个函数回调的顺序见下图<br><img src="https://raw.githubusercontent.com/njuptjsy/mobliecloudapp/master/CloudClient/uml/%E7%A2%8E%E7%89%87%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="image"></p>
<h2 id="使用限定符">使用限定符</h2><p>一个最简单的实现就是将两个相同名称不同内容的视图文件，一个单页模式的用于适应手机屏幕的布局文件存放到layout/目录下，将一个双页模式的用于适应屏幕屏幕的布局文件存放到layout-large/目录下，这样android会自动判断什么屏幕是large，在大屏幕上采用layout-large/目录下的布局文件，下表就是android默认的一些限定符的含义。<br><img src="https://raw.githubusercontent.com/njuptjsy/mobliecloudapp/master/CloudClient/uml/android%E9%99%90%E5%AE%9A%E7%AC%A6.png" alt="image"><br>自定义限定符，只需要新建相应的layout文件夹，如新建了layout-sw600dp/文件夹之后，当程序运行在屏幕宽度大于600dp 的设备上时就会加载layout-sw600dp/文件加下的文件</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android/">Android</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android-Code/">Android Code</a><a href="/tags/Skills/">Skills</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/26/Android开发技巧-碎片/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/Android/" title="Android">Android<sup>9</sup></a></li>
		  
		
		  
			<li><a href="/categories/Work/" title="Work">Work<sup>4</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Android-Code/" title="Android Code">Android Code<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/Skills/" title="Skills">Skills<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/Debug/" title="Debug">Debug<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/CloudClient/" title="CloudClient">CloudClient<sup>2</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://github.com/njuptjsy" target="_blank" title="不积跬步无以至千里">我的github</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.njupt.edu.cn" target="_blank" title="南邮">南邮</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Siyu Jin in Github. <br/>
			This is my blog,welcome.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="Siyu Jin">Siyu Jin</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>





<script type="text/javascript">

var disqus_shortname = 'guest';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
